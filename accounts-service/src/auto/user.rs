// This file was generated by gir (https://github.com/gtk-rs/gir)
// from /usr/share/gir-1.0
// from ../../gir-files
// DO NOT EDIT

use crate::{ffi,UserAccountType,UserPasswordMode};
use glib::{object::ObjectType as _,prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "ActUser")]
    pub struct User(Object<ffi::ActUser, ffi::ActUserClass>);

    match fn {
        type_ => || ffi::act_user_get_type(),
    }
}

impl User {
    #[doc(alias = "act_user_collate")]
    pub fn collate(&self, user2: &User) -> i32 {
        unsafe {
            ffi::act_user_collate(self.to_glib_none().0, user2.to_glib_none().0)
        }
    }

    #[doc(alias = "act_user_get_account_type")]
    #[doc(alias = "get_account_type")]
    #[doc(alias = "account-type")]
    pub fn account_type(&self) -> UserAccountType {
        unsafe {
            from_glib(ffi::act_user_get_account_type(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_automatic_login")]
    #[doc(alias = "get_automatic_login")]
    #[doc(alias = "automatic-login")]
    pub fn is_automatic_login(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_get_automatic_login(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_email")]
    #[doc(alias = "get_email")]
    pub fn email(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_email(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_home_dir")]
    #[doc(alias = "get_home_dir")]
    pub fn home_dir(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_home_dir(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_icon_file")]
    #[doc(alias = "get_icon_file")]
    #[doc(alias = "icon-file")]
    pub fn icon_file(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_icon_file(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_language")]
    #[doc(alias = "get_language")]
    pub fn language(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_language(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_languages")]
    #[doc(alias = "get_languages")]
    pub fn languages(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::act_user_get_languages(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_location")]
    #[doc(alias = "get_location")]
    pub fn location(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_location(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_locked")]
    #[doc(alias = "get_locked")]
    #[doc(alias = "locked")]
    pub fn is_locked(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_get_locked(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_login_frequency")]
    #[doc(alias = "get_login_frequency")]
    #[doc(alias = "login-frequency")]
    pub fn login_frequency(&self) -> i32 {
        unsafe {
            ffi::act_user_get_login_frequency(self.to_glib_none().0)
        }
    }

    //#[doc(alias = "act_user_get_login_history")]
    //#[doc(alias = "get_login_history")]
    //#[doc(alias = "login-history")]
    //pub fn login_history(&self) -> /*Ignored*/Option<glib::Variant> {
    //    unsafe { TODO: call ffi:act_user_get_login_history() }
    //}

    #[doc(alias = "act_user_get_login_time")]
    #[doc(alias = "get_login_time")]
    #[doc(alias = "login-time")]
    pub fn login_time(&self) -> i64 {
        unsafe {
            ffi::act_user_get_login_time(self.to_glib_none().0)
        }
    }

    #[doc(alias = "act_user_get_num_sessions")]
    #[doc(alias = "get_num_sessions")]
    pub fn num_sessions(&self) -> u32 {
        unsafe {
            ffi::act_user_get_num_sessions(self.to_glib_none().0)
        }
    }

    #[doc(alias = "act_user_get_num_sessions_anywhere")]
    #[doc(alias = "get_num_sessions_anywhere")]
    pub fn num_sessions_anywhere(&self) -> u32 {
        unsafe {
            ffi::act_user_get_num_sessions_anywhere(self.to_glib_none().0)
        }
    }

    #[doc(alias = "act_user_get_object_path")]
    #[doc(alias = "get_object_path")]
    pub fn object_path(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_object_path(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_password_expiration_policy")]
    #[doc(alias = "get_password_expiration_policy")]
    pub fn password_expiration_policy(&self) -> (i64, i64, i64, i64, i64, i64) {
        unsafe {
            let mut expiration_time = std::mem::MaybeUninit::uninit();
            let mut last_change_time = std::mem::MaybeUninit::uninit();
            let mut min_days_between_changes = std::mem::MaybeUninit::uninit();
            let mut max_days_between_changes = std::mem::MaybeUninit::uninit();
            let mut days_to_warn = std::mem::MaybeUninit::uninit();
            let mut days_after_expiration_until_lock = std::mem::MaybeUninit::uninit();
            ffi::act_user_get_password_expiration_policy(self.to_glib_none().0, expiration_time.as_mut_ptr(), last_change_time.as_mut_ptr(), min_days_between_changes.as_mut_ptr(), max_days_between_changes.as_mut_ptr(), days_to_warn.as_mut_ptr(), days_after_expiration_until_lock.as_mut_ptr());
            (expiration_time.assume_init(), last_change_time.assume_init(), min_days_between_changes.assume_init(), max_days_between_changes.assume_init(), days_to_warn.assume_init(), days_after_expiration_until_lock.assume_init())
        }
    }

    #[doc(alias = "act_user_get_password_hint")]
    #[doc(alias = "get_password_hint")]
    #[doc(alias = "password-hint")]
    pub fn password_hint(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_password_hint(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_password_mode")]
    #[doc(alias = "get_password_mode")]
    #[doc(alias = "password-mode")]
    pub fn password_mode(&self) -> UserPasswordMode {
        unsafe {
            from_glib(ffi::act_user_get_password_mode(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_primary_session_id")]
    #[doc(alias = "get_primary_session_id")]
    pub fn primary_session_id(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_primary_session_id(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_real_name")]
    #[doc(alias = "get_real_name")]
    #[doc(alias = "real-name")]
    pub fn real_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_real_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_saved")]
    #[doc(alias = "get_saved")]
    pub fn is_saved(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_get_saved(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_session")]
    #[doc(alias = "get_session")]
    pub fn session(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_session(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_session_type")]
    #[doc(alias = "get_session_type")]
    pub fn session_type(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_session_type(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_shell")]
    #[doc(alias = "get_shell")]
    pub fn shell(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_shell(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_uid")]
    #[doc(alias = "get_uid")]
    pub fn uid(&self) -> u32 {
        unsafe {
            ffi::act_user_get_uid(self.to_glib_none().0)
        }
    }

    #[doc(alias = "act_user_get_user_name")]
    #[doc(alias = "get_user_name")]
    #[doc(alias = "user-name")]
    pub fn user_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_user_name(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_get_x_session")]
    #[doc(alias = "get_x_session")]
    #[doc(alias = "x-session")]
    pub fn x_session(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::act_user_get_x_session(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_is_loaded")]
    #[doc(alias = "is-loaded")]
    pub fn is_loaded(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_is_loaded(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_is_local_account")]
    pub fn is_local_account(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_is_local_account(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_is_logged_in")]
    pub fn is_logged_in(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_is_logged_in(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_is_logged_in_anywhere")]
    pub fn is_logged_in_anywhere(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_is_logged_in_anywhere(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_is_nonexistent")]
    pub fn is_nonexistent(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_is_nonexistent(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_is_system_account")]
    pub fn is_system_account(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_is_system_account(self.to_glib_none().0))
        }
    }

    #[doc(alias = "act_user_set_account_type")]
    pub fn set_account_type(&self, account_type: UserAccountType) {
        unsafe {
            ffi::act_user_set_account_type(self.to_glib_none().0, account_type.into_glib());
        }
    }

    #[doc(alias = "act_user_set_automatic_login")]
    pub fn set_automatic_login(&self, enabled: bool) {
        unsafe {
            ffi::act_user_set_automatic_login(self.to_glib_none().0, enabled.into_glib());
        }
    }

    #[doc(alias = "act_user_set_email")]
    pub fn set_email(&self, email: &str) {
        unsafe {
            ffi::act_user_set_email(self.to_glib_none().0, email.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_icon_file")]
    pub fn set_icon_file(&self, icon_file: &str) {
        unsafe {
            ffi::act_user_set_icon_file(self.to_glib_none().0, icon_file.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_language")]
    pub fn set_language(&self, language: &str) {
        unsafe {
            ffi::act_user_set_language(self.to_glib_none().0, language.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_languages")]
    pub fn set_languages(&self, languages: &[&str]) {
        unsafe {
            ffi::act_user_set_languages(self.to_glib_none().0, languages.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_location")]
    pub fn set_location(&self, location: &str) {
        unsafe {
            ffi::act_user_set_location(self.to_glib_none().0, location.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_locked")]
    pub fn set_locked(&self, locked: bool) {
        unsafe {
            ffi::act_user_set_locked(self.to_glib_none().0, locked.into_glib());
        }
    }

    #[doc(alias = "act_user_set_password")]
    pub fn set_password(&self, password: &str, hint: &str) {
        unsafe {
            ffi::act_user_set_password(self.to_glib_none().0, password.to_glib_none().0, hint.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_password_expiration_policy")]
    pub fn set_password_expiration_policy(&self, min_days_between_changes: i64, max_days_between_changes: i64, days_to_warn: i64, days_after_expiration_until_lock: i64) {
        unsafe {
            ffi::act_user_set_password_expiration_policy(self.to_glib_none().0, min_days_between_changes, max_days_between_changes, days_to_warn, days_after_expiration_until_lock);
        }
    }

    #[doc(alias = "act_user_set_password_hint")]
    pub fn set_password_hint(&self, hint: &str) {
        unsafe {
            ffi::act_user_set_password_hint(self.to_glib_none().0, hint.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_password_mode")]
    pub fn set_password_mode(&self, password_mode: UserPasswordMode) {
        unsafe {
            ffi::act_user_set_password_mode(self.to_glib_none().0, password_mode.into_glib());
        }
    }

    #[doc(alias = "act_user_set_real_name")]
    pub fn set_real_name(&self, real_name: &str) {
        unsafe {
            ffi::act_user_set_real_name(self.to_glib_none().0, real_name.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_session")]
    pub fn set_session(&self, session: &str) {
        unsafe {
            ffi::act_user_set_session(self.to_glib_none().0, session.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_session_type")]
    pub fn set_session_type(&self, session_type: &str) {
        unsafe {
            ffi::act_user_set_session_type(self.to_glib_none().0, session_type.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_user_expiration_policy")]
    pub fn set_user_expiration_policy(&self, expiration_time: i64) {
        unsafe {
            ffi::act_user_set_user_expiration_policy(self.to_glib_none().0, expiration_time);
        }
    }

    #[doc(alias = "act_user_set_user_name")]
    pub fn set_user_name(&self, user_name: &str) {
        unsafe {
            ffi::act_user_set_user_name(self.to_glib_none().0, user_name.to_glib_none().0);
        }
    }

    #[doc(alias = "act_user_set_x_session")]
    pub fn set_x_session(&self, x_session: &str) {
        unsafe {
            ffi::act_user_set_x_session(self.to_glib_none().0, x_session.to_glib_none().0);
        }
    }

    #[doc(alias = "home-directory")]
    pub fn home_directory(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "home-directory")
    }

    #[doc(alias = "changed")]
    pub fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "sessions-changed")]
    pub fn connect_sessions_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn sessions_changed_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"sessions-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(sessions_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "account-type")]
    pub fn connect_account_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_account_type_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::account-type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_account_type_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "automatic-login")]
    pub fn connect_automatic_login_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_automatic_login_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::automatic-login".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_automatic_login_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "email")]
    pub fn connect_email_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_email_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::email".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_email_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "home-directory")]
    pub fn connect_home_directory_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_home_directory_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::home-directory".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_home_directory_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "icon-file")]
    pub fn connect_icon_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_icon_file_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::icon-file".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_icon_file_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "is-loaded")]
    pub fn connect_is_loaded_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_loaded_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::is-loaded".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_is_loaded_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "language")]
    pub fn connect_language_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_language_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::language".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_language_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "local-account")]
    pub fn connect_local_account_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_local_account_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::local-account".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_local_account_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "location")]
    pub fn connect_location_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_location_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::location".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_location_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "locked")]
    pub fn connect_locked_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_locked_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::locked".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_locked_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "login-frequency")]
    pub fn connect_login_frequency_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_login_frequency_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::login-frequency".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_login_frequency_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "login-history")]
    pub fn connect_login_history_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_login_history_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::login-history".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_login_history_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "login-time")]
    pub fn connect_login_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_login_time_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::login-time".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_login_time_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "nonexistent")]
    pub fn connect_nonexistent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nonexistent_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::nonexistent".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_nonexistent_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "password-hint")]
    pub fn connect_password_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_hint_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::password-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_password_hint_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "password-mode")]
    pub fn connect_password_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_mode_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::password-mode".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_password_mode_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "real-name")]
    pub fn connect_real_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_name_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::real-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_real_name_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "shell")]
    pub fn connect_shell_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_shell_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::shell".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_shell_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "system-account")]
    pub fn connect_system_account_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_system_account_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::system-account".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_system_account_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "uid")]
    pub fn connect_uid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uid_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::uid".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_uid_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "user-name")]
    pub fn connect_user_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_user_name_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::user-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_user_name_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "x-session")]
    pub fn connect_x_session_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_session_trampoline<F: Fn(&User) + 'static>(this: *mut ffi::ActUser, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::x-session".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_x_session_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}
